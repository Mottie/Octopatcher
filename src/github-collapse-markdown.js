// @name         GitHub Collapse Markdown
// @version      1.1.0
// @description  A script that collapses markdown headers
// @license      https://creativecommons.org/licenses/by-sa/4.0/
// @namespace    https://github.com/Mottie
// @author       Rob Garrison
// @source       https://github.com/Mottie/GitHub-userscripts (extension converted from github-collapse-markdown.user.js)
/* jshint esnext:true, unused:true */
/* global chrome */
(() => {
  "use strict";

  // defaults ALSO set in options.js
  let defaults = {
    mc_enabled : true,
    mc_animated : true,
    // palette generated by http://tools.medialab.sciences-po.fr/iwanthue/ (colorblind friendly, soft)
    mc_colors : ["#6778d0", "#ac9c3d", "#b94a73", "#56ae6c", "#9750a1", "#ba543d"],
    mc_state : "e" // "c" = collapsed; "e" = expanded
  },
  settings = defaults,

  headers = "H1 H2 H3 H4 H5 H6".split(" "),
  collapsed = "ghcm-collapsed";

  function addColors(settings) {
    let colors = settings.mc_colors;
    if (colors && colors.length === 6 && $(".ghcm-colors")) {
      $(".ghcm-colors").textContent = `
        .markdown-body h1:after, .markdown-format h1:after { color:${colors[0]} }
        .markdown-body h2:after, .markdown-format h2:after { color:${colors[1]} }
        .markdown-body h3:after, .markdown-format h3:after { color:${colors[2]} }
        .markdown-body h4:after, .markdown-format h4:after { color:${colors[3]} }
        .markdown-body h5:after, .markdown-format h5:after { color:${colors[4]} }
        .markdown-body h6:after, .markdown-format h6:after { color:${colors[5]} }
      `;
    }
  }

  function toggle(el, shifted) {
    if (el) {
      el.classList.toggle(collapsed);
      let els,
        name = el.nodeName || "",
        // convert H# to #
        level = parseInt(name.replace(/[^\d]/, ""), 10),
        isCollapsed = el.classList.contains(collapsed);
      if (shifted) {
        // collapse all same level anchors
        els = $$(`.markdown-body ${name}, .markdown-format ${name}`);
        for (el of els) {
          nextHeader(el, level, isCollapsed);
        }
      } else {
        nextHeader(el, level, isCollapsed);
      }
      removeSelection();
    }
  }

  function onAnimationEnd(els, fn) {
    if (settings.mc_animated) {
      els.forEach(el => {
        const listener = () => {
          fn();
          // remove listener after event fired
          el.removeEventListener("animationend", listener);
          el.removeEventListener("webkitAnimationEnd", listener);
        };
        el.addEventListener("animationend", listener);
        el.addEventListener("webkitAnimationEnd", listener);
      });
    } else {
      fn();
    }
  }

  function nextHeader(el, level, isCollapsed) {
    el.classList.toggle(collapsed, isCollapsed);
    let selector = headers.slice(0, level).join(","),
      els = [];
    el = el.nextElementSibling;
    while (el && !el.matches(selector)) {
      els[els.length] = el;
      el = el.nextElementSibling;
    }
    if (els.length) {
      if (isCollapsed) {
        if (!settings.mc_animated) {
          addClass(els, "end");
        }
        addClass(els, "ghcm-hidden"); // fade out
        onAnimationEnd(els, () => {
          // add .end class for hiding content after animation end
          addClass(els, "end");
        });
      } else {
        removeClass(els, collapsed + " ghcm-hidden end");
        if (settings.mc_animated) {
          addClass(els, "ghcm-visible"); // fade in
          onAnimationEnd(els, () => {
            removeClass(els, "ghcm-visible end");
          });
        }
      }
    }
  }

  // show siblings of hash target
  function siblings(target) {
    let level = parseInt((target.nodeName || "").replace(/[^\d]/, ""), 10),
      el = target.nextElementSibling,
      selector = headers.slice(0, level - 1).join(","),
      els = [target];
    while (el && !el.matches(selector)) {
      els[els.length] = el;
      el = el.nextElementSibling;
    }
    el = target.previousElementSibling;
    while (el && !el.matches(selector)) {
      els[els.length] = el;
      el = el.previousElementSibling;
    }
    if (els.length) {
      els = els.filter(el => el.nodeName === target.nodeName);
      removeClass(els, "ghcm-hidden");
    }
    nextHeader(target, level, false);
  }

  function removeSelection() {
    // remove text selection - http://stackoverflow.com/a/3171348/145346
    var sel = window.getSelection ? window.getSelection() : document.selection;
    if (sel) {
      if (sel.removeAllRanges) {
        sel.removeAllRanges();
      } else if (sel.empty) {
        sel.empty();
      }
    }
  }

  function checkHash() {
    let el, els, md, tmp,
      mds = $$(".markdown-body, .markdown-format");
    for (md of mds) {
      els = $$(headers.join(","), md);
      if (els.length > 1) {
        for (el of els) {
          if (el && !el.classList.contains(collapsed)) {
            toggle(el, true);
          }
        }
      }
    }
    // open up
    tmp = (window.location.hash || "").replace(/#/, "");
    if (tmp) {
      els = $(`#user-content-${tmp}`);
      if (els && els.classList.contains("anchor")) {
        el = els.parentNode;
        if (el.matches(headers.join(","))) {
          siblings(el);
          document.documentElement.scrollTop = el.offsetTop;
          // set scrollTop a second time, in case of browser lag
          setTimeout(() => {
            document.documentElement.scrollTop = el.offsetTop;
          }, 500);
        }
      }
    }
  }

  function checkColors(colors) {
    if (!colors || colors.length !== 6) {
      colors = [].concat(defaults.mc_colors);
    }
    return colors;
  }

  function addArrows() {
    let styles = document.createElement("style");
    styles.className = "ghcm-arrows";
    styles.textContent = `
      .markdown-body h1, .markdown-body h2, .markdown-body h3,
      .markdown-body h4, .markdown-body h5, .markdown-body h6,
      .markdown-format h1, .markdown-format h2, .markdown-format h3,
      .markdown-format h4, .markdown-format h5, .markdown-format h6 {
        position: relative;
        padding-right: .8em;
        cursor: pointer;
      }
      .markdown-body h1:after, .markdown-body h2:after, .markdown-body h3:after,
      .markdown-body h4:after, .markdown-body h5:after, .markdown-body h6:after,
      .markdown-format h1:after, .markdown-format h2:after, .markdown-format h3:after,
      .markdown-format h4:after, .markdown-format h5:after, .markdown-format h6:after {
        display: inline-block;
        position: absolute;
        right: 0;
        top: calc(50% - .5em);
        font-size: .8em;
        content: "\u25bc";
        transition: transform .3s ease;
        -webkit-transition: transform .3s ease;
      }
      .markdown-body .${collapsed}:after, .markdown-format .${collapsed}:after {
        transform: rotate(90deg);
      }
      /* clicking on header link won't pass svg as the event.target */
      .octicon-link, .octicon-link > * {
        pointer-events: none;
      }
      .ghcm-hidden {
        animation: fade-out .5s;
        animation-fill-mode: forwards;
        -webkit-animation: fade-out .5s;
        -webkit-animation-fill-mode: forwards;
        transform-origin: top;
      }
      .ghcm-hidden.end {
        display: none !important;
      }
      .ghcm-visible {
        animation: fade-in .5s;
        animation-fill-mode: forwards;
        -webkit-animation: fade-in .5s;
        -webkit-animation-fill-mode: forwards;
        transform-origin: top;
      }
      @keyframes fade-in {
        from {
          opacity: 0;
          transform: scaleY(0);
        }
        to {
          opacity: 1;
          transform: scaleY(1);
        }
      }
      @-webkit-keyframes fade-in {
        from {
          opacity: 0;
          transform: scaleY(0);
        }
        to {
          opacity: 1;
          transform: scaleY(1);
        }
      }
      @keyframes fade-out {
        from {
          opacity: 1;
          transform: scaleY(1);
        }
        to {
          opacity: 0;
          transform: scaleY(0);
        }
      }
      @-webkit-keyframes fade-out {
        from {
          opacity: 1;
          transform: scaleY(1);
        }
        to {
          opacity: 0;
          transform: scaleY(0);
        }
      }
    `;
    $("head").appendChild(styles);

    styles = document.createElement("style");
    styles.className = "ghcm-colors";
    $("head").appendChild(styles);
  }

  // addBinding() from userscript
  function init() {
    document.addEventListener("click", event => {
      let target = event.target,
        name = (target && target.nodeName || "").toLowerCase();
      if (name === "path") {
        target = closest("svg", target);
      }
      if (!target || target.classList.contains("anchor") ||
        name === "a" || name === "img" ||
        // add support for "pointer-events:none" applied to "anchor" in
        // https://github.com/StylishThemes/GitHub-FixedHeader
        target.classList.contains("octicon-link")) {
        return;
      }
      // check if element is inside a header
      target = closest(headers.join(","), event.target);
      if (target && headers.indexOf(target.nodeName || "") > -1) {
        // make sure the header is inside of markdown
        if (closest(".markdown-body, .markdown-format", target)) {
          toggle(target, event.shiftKey);
        }
      }
    });
  }

  function update(vals) {
    settings = Object.assign({}, defaults, settings, vals);
    removeClass($$("." + collapsed + ", .ghcm-hidden"), collapsed + " ghcm-hidden");
    if (settings.mc_enabled) {
      addArrows();
      settings.mc_colors = checkColors(settings.mc_colors);
      addColors(settings);

      if (settings.mc_state === "c") {
        checkHash();
      }
    } else {
      // not enabled, remove styles
      removeAll(".ghcm-colors, .ghcm-arrows");
    }
  }

  function $(selector, el) {
    return (el || document).querySelector(selector);
  }

  function $$(selectors, el) {
    return Array.from((el || document).querySelectorAll(selectors));
  }

  function addClass(els, name) {
    for (let el of els) {
      el.classList.add(name);
    }
  }

  function removeClass(els, name) {
    name = (name || "").split(" ");
    for (let el of els) {
      el.classList.remove(...name);
    }
  }

  function closest(selector, el) {
    while (el && el.nodeType === 1) {
      if (el.matches(selector)) {
        return el;
      }
      el = el.parentNode;
    }
    return null;
  }

  function removeAll(selector) {
    $$(selector).forEach(el => {
      el.parentNode.removeChild(el);
    });
  }

  init();

  // Firefox does not support chrome.storage.sync :(
  // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/storage#Chrome_incompatibilities
  // The storage API is not supported in content scripts.
  let storageType = chrome.storage && chrome.storage.sync ? "sync" : "local";
  chrome.storage[storageType].get(defaults, vals => {
    update(vals);
  });
  chrome.storage.onChanged.addListener(() => {
    chrome.storage[storageType].get(defaults, vals => {
      update(vals);
    });
  });
})();
